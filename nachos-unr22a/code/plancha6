1-

Hipervisores:
son una capa fina de software que se activa solo cuando el S.O. virtualizado quiere acceder al hardware.

-ventajas: 

-desventajas: 

Emulación:
son programas de usuario que emulan las instrucciones que acceden al hardware.

-ventajas:
	-se pueden emular arquitecturas inexistentes.
-desventajas: 
	-deben emular todas las caracteristicas de la arquitectura, todas las llamas al sistema de los perifericos, buses, microchips.
	-el SO que se esta ejecutando puede hacerlo de manera mas lenta que si lo hiciese nativamente pues el guest debe trasformar todas las
	 instruciones a la arquitectura subyasente.

Paravirtualización:
Un hipervisor de paravirtualización es prácticamente un microkernel que ejecuta S.O. huespedes como procesos.
Es necesario que el SO a ejecutarse sea modificado para que en vez de utilizar I/O se refiera a la API del hipervisor.

-ventajas:
	-menos costoso que emulación pues no se tiene que emular toda la arquitectura.
	-el hipervisor es sencillo y por ende menos propenso a bugs
-desventajas:
	-se debe modificar el SO a ejecutarse para que utilice la API propuesta y no acceda directamente a los dispositivos I/O y demas.




2-

Una shadow page table es, como su nombre lo indica, una tabla que almacena las traducciones de las paginas que le dio
al S.O. huesped.
Son utilizadas por el hipervisor para realizar un seguimiento del estado en el que el huésped "piensa" que deberían estar
sus tablas de paginacion. Estos es dado que no se le puede permitir acceso a las paginas del hardware ya que tendria que tener acceso a la máquina.

4 - 
4.2. Un algoritmo distribuido
El primer algoritmo distribuido fue presentado por Lamport. Veremos una versi´on m´as
eficiente propuesta por Ricart y Agrawala en 1981. Este algoritmo requiere que todos los
eventos en el sistema tengan un orden total (basado en un timestamp): dados dos mensajes
y/o eventos debe poder saberse de forma no ambigua cu´al de los dos se considera que
ocurri´o primero (otro algoritmo de Lamport permite garantizar eso). Tambi´en se asume
que la entrega de paquetes es confiable (i.e.: hay un acknowledge o “acuse de recibo”).
Ahora para ingresar a una secci´on cr´ıtica un proceso construye un paquete con el
pedido que incluye: el nombre de la regi´on cr´ıtica, su n´umero de proceso y la hora actual.
Este mensaje es enviado a todos los miembros del grupo y se espera a que todos los
miembro del grupo respondan OK.
Cuando otro proceso recibe el pedido pueden darse tres casos:
No tiene intenciones de ingresar en esa regi´on cr´ıtica, entonces responde OK.
Est´a en la regi´on cr´ıtica: encola el pedido para responderlo cuando termine de usar
esa regi´on.
Necesita entrar en la regi´on cr´ıtica pero todav´ıa no recibi´o todas las autorizaciones.
En este caso compara el timestamp que le llega con el timestamp que envi´o en
su pedido. El m´as bajo gana: si el mensaje entrante tiene el timestamp m´as bajo
entonces responde OK (lo que eventualmente habilitar´a al otro proceso). En caso
contrario encola la petici´on (este proceso entrar´a antes a la secci´on cr´ıtica).
Cuando un proceso termina de usar la regi´on cr´ıtica env´ıa OK a todos los procesos
que estaban esperando por ella.
Desventaja: ahora se necesitan 2(n − 1) paquetes si hay n nodos en la red
Ventaja: No hay un servidor o coordinador, no hay ´unico punto de falla
Desventaja: ¡¡ahora hay n puntos de falla!!
3
Se puede mejorar un poco: no es necesario esperar que todos respondan, se puede
cambiar un poco para que con la respuesta de una mayor´ıa de los procesos ya se tenga
suficiente concenso para continuar.
M´as desventajas: requiere que se conozca quienes son todos los miembros del grupo,
si no se recibe respuesta puede ser que el proceso est´e en una secci´on cr´ıtica pero tambi´en
que el nodo se haya ca´ıdo.
Nuevamente, se pueden hacer m´as mejoras, pero de cualquier manera el algoritmo
ser´a m´as lento, m´as complicado, m´as caro y menos robusto que el algoritmo centralizado.
En conclusi´on: si bien existen algoritmos distribuidos para este problema muchas
veces tener un proceso coordinador simplifica mucho la cosa. As´ı, para muchos casos se
utiliza un coordinador y se aplican algoritmos de elecci´on de lider para reelegir un nuevo
coordinador en caso de que un coordinador deje de estar disponibile.
4.3. Algoritmo basado en anillo
Otra alternativa es utilizar una topolog´ıa l´ogica basada en token ring: los procesos
(o nodos) estar´an ordenados l´ogicamente en un anillo y un token (un paquete especial)
circular´a por el anillo: s´olo el proceso que tiene el token puede acceder a la secci´on cr´ıtica
(sencillamente retendr´a el token hasta salir de la secci´on cr´ıtica). Este algoritmo tiene
varias ventajas pero tambi´en tiene todas las ventajas de una arquitectura basada en
anillo.


5 - 
En general usamos sistemas distribuidos para distinguirlo de sistemas centralizados
consistentes en una ´unica CPU, memoria, perif´ericos y alguna terminal. Aqu´ı quiz´as
convenga considerar que nos preocuparemos por el software (m´as que por el hardware)
que no siempre podr´a confiar en tener una memoria compartida ni en que los mensajes
llegar´an siempre y en orden. Tambi´en habr´a que tener en cuenta que la red puede caerse
total o parcialmente y lo mismo puede suceder con algunos nodos (o CPUs) que incluso
pueden volver a aparecer en un tiempo.
1.2. ¿Por qu´e se usan sistemas distribuidos? Ventajas
Actualmente las ventajas son muchas:
Precio/rendimiento: el poder de c´omputo de 200 procesadores econ´omicos interconectados puede ser mucho mayor que el del mejor procesador disponible.
Distribuci´on necesaria o eficiente: sistema de reserva de vuelos, nodos cercanos
brindar´an una respuesta r´apida.
Seguridad (alta disponibilidad): tener muchas copias de datos y servicios permite
brindar m´as confiabilidad en el caso de que un nodo deje de funcionar.
Crecimiento exponencial: un sistema que inicialmente atender´a poco pedidos puede
comenzar a trabajar con un pocos nodos y a medida que el negocio crece pueden ir
agreg´andose m´as nodos para poder seguir brindando la misma calidad de servicio.
1.3. Problemas y desventajas
Los sistemas distribuidos a˜naden complejidad, principalmente:
Software: el acceso concurrente y la divisi´on de tareas ya son conceptos que aparecen
en sistemas paralelos o concurrentes.
Como no hay memoria compartida y se depende de una red que tal vez no sea tan
estable los mensajes y nodos pueden perderse y/o llegar desordenados.
Seguridad: tener los datos y servicios disponibiles en una red involucra nuevos problemas de seguridad.
1
2. Transparencia
De acuerdo al tipo de sistema puede ser necesario brindar una o m´as formas de
transparencia. Lo ´optimo ser´ıa combinarlas todas.
Ubicaci´on: el usuario no puede decir d´onde est´an ubicados los recursos
Migraci´on: los recursos pueden moverse sin cambiar de nombre
Replicaci´on: el usuario no puede saber cu´antas copias hay de un recurso
Concurrencia: los recursos pueden compartirse autom´aticamente con muchos usuarios
Paralelismo: las acciones pueden realizarse en paralelo sin que el usuario lo sepa

6 